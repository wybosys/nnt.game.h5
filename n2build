#!/usr/bin/env python3
# -*- coding: utf-8 -*-

import sys, getopt, os, os.path, shelve, configparser, hashlib, string, codecs, shutil, datetime, re, zipfile, binascii, time, zlib, signal, subprocess
import socket, threading, base64, json, struct, multiprocessing, uuid, functools
from xml.dom import minidom

# 判断必备模块
try:
    import watchdog, watchdog.observers, watchdog.events
except Exception as err:
    print('请先使用 sudo pip install watchdog 安装模块')
    sys.exit(0)

try:
    import lxml
except Exception as err:
    print('请先使用 sudo pip install lxml 安装模块')
    sys.exit(0)

try:
    import openpyxl
except Exception as err:
    print('请先使用 sudo pip install openpyxl 安装模块')
    sys.exit(0)

try:
    from PIL import Image
except:
    print('请先使用 sudo pip install pillow 安装模块')
    sys.exit(0)    
    
if len(subprocess.getoutput('which npm')) == 0:
    print('请先使用 sudo port install npm 安装node.js环境')
    sys.exit(0)

if len(subprocess.getoutput('which tsc')) == 0:
    print('请先使用 sudo npm install -g typescript 安装Typescript环境')
    sys.exit(0)

if len(subprocess.getoutput('which md5sum')) == 0:
    print('请显示用 sudo port install md5sha1sum 安装必要工具')
    sys.exit(0)

if len(subprocess.getoutput('which wget')) == 0:
    print('请显示用 sudo port install wget 安装必要工具')
    sys.exit(0)
    
cfgdb = None
version = '1.0.0'
HOMEDIR = os.getenv("HOME") + '/'
if not os.path.isdir('.n2~'):
    os.mkdir('.n2~')

def usage():
    print("""
    n2build <-ht> <debug|publish|config|api file> \n
    -h 帮助
    -t 不启动service
    debug \t 调试模式，默认
    publish \t 发布模式，版本号使用config定义
    dist <debug> \t 打包模式，除了publish的功能，额外会把publish/resource的目录压缩一遍
    clean \t 清空
    config \t 使用引导来配置当前项目
    service <list|stop> \t 控制n2build的服务
    genres \t 生成res.json文件
    pubres \t 发布resource到publish中
    checkout \t 切换分支
    debugindex \t 生成debugindex(windows编译出来的index.html中的文件顺序不对的时候需要在mac上生成debug.html)
    """)

# 跨进程锁实现
try:  
    import fcntl  
    LOCK_EX = fcntl.LOCK_EX
except ImportError:  
    # windows平台下没有fcntl模块  
    fcntl = None 
    import win32con  
    import win32file  
    import pywintypes  
    LOCK_EX = win32con.LOCKFILE_EXCLUSIVE_LOCK  
    overlapped = pywintypes.OVERLAPPED()

class GlobalLock:      
    def __init__(self, name):  
        self.name = '.n2~/' + name + '.locker~'
        self.handle = open(self.name, 'w')   
    def acquire(self):
        try:
            if fcntl:
                fcntl.flock(self.handle, LOCK_EX | fcntl.LOCK_NB)
            else:  
                hfile = win32file._get_osfhandle(self.handle.fileno())  
                win32file.LockFileEx(hfile, LOCK_EX, 0, -0x10000, overlapped)
            ret = True
        except:
            ret = False
        return ret            
    def release(self):
        try:
            if fcntl:  
                fcntl.flock(self.handle, fcntl.LOCK_UN)  
            else:  
                hfile = win32file._get_osfhandle(self.handle.fileno())  
                win32file.UnlockFileEx(hfile, 0, -0x10000, overlapped)
        except:
            pass
    def __del__(self):
        #try:  
        #    self.handle.close()  
        #    os.remove(self.name)  
        #except:  
        #    pass
        pass #会干扰n2build的挂进程svc服务，造成重复启动

# 使用md5散列文件
def hashfile(file):
    if not os.path.isfile(file):
        return "not found"
    res = subprocess.getoutput('md5sum ' + file).split(" ")
    return res[0]

def filesize(file):
    st = os.stat(file)
    return st.st_size

# 高性能的简单散列
def simplehashfile(file):
    st = os.stat(file)
    d = ':'.join([str(st.st_size),
                    str(st.st_mtime),
                    str(st.st_ctime)])
    return hashstring(d)

# 简单获取服务相关的临时文件名
_tmpfilecounter = 0
def tempfilename():
    global _tmpfilecounter
    _tmpfilecounter = _tmpfilecounter + 1
    return str(_tmpfilecounter)

def hashstring(str):
    return hashlib.md5(str.encode("utf-8")).hexdigest()

def isImage(file):
    reximg = re.compile(r'(\.png$)|(\.jpg$)')
    return reximg.search(file) != None

def makeconfig(recfg):
    """使用引导来生成项目的构建配置文件 .n2.cfg"""
    cfg = configparser.SafeConfigParser()
    if recfg:
        cfg.read('.n2.cfg')
    def wait_input(s, k, h):
        if not cfg.has_section(s):
            cfg.add_section(s)
        if cfg.has_option(s, k):
            t = cfg.get(s, k)
        else:
            t = ''
        v = input(h + [' 当前(' + t + ')', ''][not t] + ':') or t
        cfg.set(s, k, v)
    wait_input('app', 'name', '游戏名称')
    wait_input('app', 'icon', 'ICON的路径')
    wait_input('app', 'background', '背景')
    wait_input('app', 'background-color', '背景颜色')
    wait_input('app', 'orientation', '方向 [h]ov/[v]ec')
    wait_input('app', 'resource', '资源的模式 [d]ebug/[p]ublish]')
    wait_input('app', 'version', '版本号')
    wait_input('dev', 'genresdb', '自动生成资源数据 [y]es/[n]o')
    wait_input('dev', 'automerge', '自动合并资源 [y]es/[n]o')
    cfg.write(open('.n2.cfg', 'w'))
    
def checkconfig():    
    """检查决策此次工作的配置"""
    if not os.path.isfile('.n2.cfg'):
        makeconfig(False)
    if 'uuid' not in cfgdb:
        cfgdb['uuid'] = str(uuid.uuid4())
    # 比对是否n2build升版
    if 'bver' not in cfgdb or cfgdb['bver'] != version:
        print("n2b版本变更")
        return True    
    # 比对配置文件是否修改过
    cfghash = hashfile('.n2.cfg')
    if 'cfghash' not in cfgdb or cfgdb['cfghash'] != cfghash:
        cfgdb['cfghash'] = cfghash
        print("项目配置变更")
        return True
    # 比对n2build是否修改过
    n2bhash = hashfile('n2build')
    if 'n2bhash' not in cfgdb or cfgdb['n2bhash'] != n2bhash:
        cfgdb['n2bhash'] = n2bhash
        print("n2b变更")
        return True
    # 比对egretProp是否修改过
    props = hashfile('egretProperties.json')
    if 'propshash' not in cfgdb or cfgdb['propshash'] != props:
        cfgdb['propshash'] = props
        print("egret配置变更")
        return True
    return False

# 提取app.html中引用独立定义的加载样式
def apphtmlinfo(debug):
    r = {'APPSTYLE':"",
         'APPLAUNCH':"",
         'APPSCRIPT':""}
    # 如果直接返回r则代表不使用app.html
    if not os.path.exists("src/app/app.html"):
        return r
    cfg = configparser.ConfigParser()
    cfg.read('.n2.cfg')
    from lxml import etree
    content = readfile("src/app/app.html")
    # 替换掉assets形式的定义
    if debug == True:
        content = content.replace('assets://', 'resource/assets/')
    else:
        content = content.replace('assets://', 'resource_' + cfg.get('app', 'version') + '/assets/')
    html = etree.HTML(content)
    node = html.find('body').find('style')
    if node != None:
        r['APPSTYLE'] = etree.tostring(node, encoding='utf-8', method='html')
    node = html.find('body').find('div')
    if node != None:
        r['APPLAUNCH'] = etree.tostring(node, encoding='utf-8', method='html')
    node = html.find('body').find('script')
    if node != None:
        r['APPSCRIPT'] = etree.tostring(node, encoding='utf-8', method='html')
    return r

def pdindex():
    """生成调试用的index相关文件"""
    print("生成debug的index.html")
    cfg = configparser.ConfigParser()
    cfg.read('.n2.cfg')
    bkg = cfg.get('app', 'background')
    bkgcolor = cfg.get('app', 'background-color')    
    if bkg.startswith('assets://'):
        bkg = bkg.replace('assets://', 'resource/assets/')
    appinfo = apphtmlinfo(True)
    # 读取js列表
    manifest = json.loads(readfile('manifest.json'))
    files = []
    for each in manifest['initial'] + manifest['game']:
        files.append('<script src="' + each + '"></script>')
    index = string.Template(TPL_INDEX_DEBUG).substitute({
        'APPNAME': cfg.get('app', 'name'),
        'APPORI': ['portrait', 'landscape'][cfg.get('app', 'orientation') == 'h'],
        'APPANGLE': ['0', '90'][cfg.get('app', 'orientation') == 'h'],
        'APPCONTENT': 'version=0.0.1, debug, verbose' + ['', ', publish'][cfg.get('app', 'resource') == 'p'],
        'BACKGROUND': bkg,
        'BACKGROUNDCOLOR': bkgcolor,
        'APPSTYLE': appinfo['APPSTYLE'],
        'APPLAUNCH': appinfo['APPLAUNCH'],
        'APPSCRIPT': appinfo['APPSCRIPT'],
        'FILESLIST': '\n\t'.join(files)
    })
    open('index.html', 'w').write(index)
    # 为了支持插件调试模式，需要描述一下当前项目的信息
    open('src/app/~debug.js', 'w').write(string.Template("""
var app = {};
app.debug = {
    PATH:"${PATH}",
    UUID:"${UUID}",
    CONFIG:${CONFIG},
    BUILDDATE:${BUILDDATE}
};
""").substitute({
    'PATH': os.getcwd(),
    'UUID': cfgdb['uuid'],
    'CONFIG': ['false', 'true'][os.path.exists('~debug.json')],
    'BUILDDATE': int(time.time())
    }))

def prindex():
    # 处理最新的文件
    print("生成release版的index.html")
    if not os.path.isdir('publish'):
        os.mkdir('publish')
    """生成发布版本的index相关文件"""
    cfg = configparser.ConfigParser()
    cfg.read('.n2.cfg')
    bkg = cfg.get('app', 'background')
    bkgcolor = cfg.get('app', 'background-color')
    if bkg.startswith('assets://'):
        if cfg.get('app', 'resource') == 'p':            
            bkg = bkg.replace('assets://', 'resource_' + cfg.get('app', 'version') + '/assets/')
        else:
            bkg = bkg.replace('assets://', 'resource/assets/')
    appinfo = apphtmlinfo(False)
    index = string.Template(TPL_INDEX_RELEASE).safe_substitute({
        'APPNAME': cfg.get('app', 'name'),
        'APPORI': ['portrait', 'landscape'][cfg.get('app', 'orientation') == 'h'],
        'APPANGLE': ['0', '90'][cfg.get('app', 'orientation') == 'h'],
        'APPCONTENT': 'version=' + cfg.get('app', 'version') + ['', ', publish'][cfg.get('app', 'resource') == 'p'],
        'APPVERSION': cfg.get('app', 'version'),
        'APPICON': cfg.get('app', 'icon'),
        'BACKGROUND': bkg,
        'BACKGROUNDCOLOR' : bkgcolor,
        'APPSTYLE': appinfo['APPSTYLE'],
        'APPLAUNCH': appinfo['APPLAUNCH'],
        'APPSCRIPT': appinfo['APPSCRIPT'],
        'FILESLIST': '\n\t'.join([
            '<script src="engine.min.js?v=' + cfg.get('app', 'version') + '"></script>',
            '<script src="main.min.js?v=' + cfg.get('app', 'version') + '"></script>'
        ])
    })
    open('publish/index.html', 'w').write(index)

def readfile(file):
    return ''.join(open(file).readlines())

def combinefiles(files, dest):
    cnt = []
    for file in files:
        cnt.append(readfile(file))
    open(dest, 'w').write('\n'.join(cnt))

def prebuildsrc():
    print("处理附加数据")
    # 处理 tsd 文件
    if not os.path.exists('src/app/~tsc'):
        os.mkdir('src/app/~tsc')
    # 查找所有的tsd, 保存hash到对照表
    tscdb = shelve.open('src/app/~tsc/.prebuild')
    # 处理所有的tsc文件
    files = listfiles('src/app/data', whitelist=[re.compile(r'\.tsc$')])
    for file in files:
        hash = simplehashfile(file)
        key = file.replace('/', '_')
        if key not in tscdb or tscdb[key] != hash:            
            prebuild_tsc(file, key)
            tscdb[key] = hash
    # 处理所有的excel文件
    files = listfiles('src/app/data', whitelist=[re.compile(r'\.xlsx$'),re.compile(r'\.xls$')])
    for file in files:
        if os.path.basename(file).startswith('~'):
            continue
        hash = simplehashfile(file)
        key = file.replace('/', '_')
        if key not in tscdb or tscdb[key] != hash:            
            prebuild_xls(file, key)
            tscdb[key] = hash
    tscdb.close()
    # 合并处理过的所有文件到resource中，形成一个唯一的js
    files = listfiles('src/app/~tsc', whitelist=[re.compile(r'\.js$')])
    combinefiles(files, 'resource/default.data.js')

def prebuild_tsc(file, key):
    print('处理 ' + file)
    shutil.copyfile(file, 'src/app/~tsc/doing.ts')
    # 生成 d.ts 文件
    subprocess.getoutput('tsc -d -t es5 --outDir src/app/~tsc src/app/~tsc/doing.ts')
    shutil.move('src/app/~tsc/doing.d.ts', 'src/app/~tsc/' + key + '.d.ts')
    shutil.move('src/app/~tsc/doing.js', 'src/app/~tsc/' + key + '.js')
    os.unlink('src/app/~tsc/doing.ts')

def prebuild_xls(file, key):
    print('处理 ' + file)
    d = openpyxl.reader.excel.load_workbook(file, data_only=True)
    for e in d.sheetnames:
        prebuild_xls_sheet(d, e, key + '_' + e.lower())

def prebuild_xls_sheet(xls, name, key):
    sh = xls.get_sheet_by_name(name)    
    # 第一行是说明，第二行是id会变成property，第三行是数据定义行，其他行是数据
    # 查找id位于的colid
    colids = []
    colnames = []
    idxid = None
    for col in range(sh.max_column):
        cell = sh.cell(row=2, column=col+1)
        val = cell.value
        if val != None:
            colids.append(col+1)
            colnames.append(val)
            if val == 'id':
                idxid = col+1
    # 根据第一行的数据类型生成基础的类型定义
    props = []
    for i in range(len(colids)):
        col = colids[i]
        cell = sh.cell(row=4, column=col)
        val = cell.value        
        valtype = 'number'
        if val == None:
            valtype = 'string'
        elif isinstance(val, str):
            valtype = 'string'
        prop = string.Template("""
        get ${NAME}():${TYPE} { return this._obj[${INDEX}]; }
        static ${NAME}Index = ${INDEX};
        """                                   
        ).substitute({
            'NAME':colnames[i],
            'TYPE':valtype,
            'INDEX':i
        })
        props.append(prop)
    # 拼装所有行数据
    rowdatas = []
    rowids = []
    for row in range(4, sh.max_row+1):
        rowid = row - 4
        if idxid != None:
            rowid = sh.cell(row=row, column=idxid).value
        rowdata = []
        for i in range(len(colids)):
            col = colids[i]
            val = sh.cell(row=row, column=col).value
            rowdata.append(val)
        rowids.append(rowid)
        rowdatas.append(rowdata)
    # 输出
    output_xlsdata_tots(name, rowids, rowdatas, props, key)
    
def output_xlsdata_tots(name, ids, datas, props, key):
    # 转换datas到对应的jsobj结构的数据
    jsobjs = []
    for i in range(len(ids)):
        jsobjs.append('"' + str(ids[i]) + '":' + name.lower() + 'Cfgs[' + str(i) + ']')
    # 输出成ts再使用tsc变异成dts和对应js文件，降低性能影响
    cnt = string.Template("""module Data { 
    export var ${NAME}Cfgs:any[] = ${CFGS};
    export var ${NAME}s:any = ${DATA};
    export class ${CLASS} {
    constructor(obj) { this._obj = obj; }
    private _obj:any;
    ${PROPERTIES}
    }
    export function get${CLASS}(id:any):${CLASS} { return new ${CLASS}(${NAME}s[id]); }
    }""").substitute({
        'NAME':name.lower(),
        'CLASS':name[0].upper() + name[1:],
        'CFGS':json.dumps(datas, indent=4),
        'DATA':'{' + ','.join(jsobjs) + '}',
        'PROPERTIES':''.join(props)
    }).encode('utf-8').decode('unicode_escape')
    codecs.open('src/app/~tsc/doing.ts', 'w', 'utf-8').write(cnt)
    # 输出js
    subprocess.getoutput('tsc -d -t es5 --outDir src/app/~tsc src/app/~tsc/doing.ts')
    shutil.move('src/app/~tsc/doing.d.ts', 'src/app/~tsc/' + key + '.d.ts')
    shutil.move('src/app/~tsc/doing.js', 'src/app/~tsc/' + key + '.js')
    os.unlink('src/app/~tsc/doing.ts')

def builddebug():
    print("编译debug版本")
    # 预处理工程代码
    prebuildsrc()
    # 去除publish引起的egret混乱
    shutil.rmtree('publish', True)
    # 判断使用何种编译
    print(egret_cmd('build'))

def copydebugtopublish():
    print("拷贝debug文件到publish")
    if not os.path.isdir('publish'):
        os.mkdir('publish')
    shutil.copytree('tools', 'publish/tools')
    shutil.copytree('libs', 'publish/libs')
    shutil.copytree('src/app/~tsc', 'publish/src/app/~tsc')
    shutil.copytree('bin-debug', 'publish/bin-debug')
    shutil.copytree('resource', 'publish/resource')
    shutil.copy('src/app/~debug.js', 'publish/src/app/')
    shutil.copy('index.html', 'publish/')
    shutil.copy('app.json', 'publish/')
    # 判断是否需要合并
    cfg = configparser.ConfigParser()
    cfg.read('.n2.cfg')
    if cfg.get('dev', 'automerge') == 'y':
        print("合并图片")
        processdirs('publish/resource/assets', automergeimages, blacklist=GENRES_BLACKS, depth=2)
        genresdbdirectory('publish')

def lines_between(lines, begin, end):
    ret = []
    match = False
    rexbeg = re.compile(begin)
    rexend = re.compile(end)
    for line in lines:
        if not match:                
            if rexbeg.search(line):
                match = True
            continue
        if rexend.search(line):
            break
        ret.append(line)
    return ret

def lines_replace(lines, begin, end, reps):
    match = False
    rexbeg = re.compile(begin)
    rexend = re.compile(end)
    idxbeg = -1
    idxend = -1
    idx = -1
    for line in lines:
        idx += 1
        if not match:                
            if rexbeg.search(line):                
                match = True
                idxbeg = idx
            continue
        if rexend.search(line):
            idxend = idx
            break
    if idxbeg == -1 or idxend == -1:
        return lines
    l = lines[:idxbeg+1]
    r = lines[idxend:]
    return l + reps + r

def lines_insert(lines, find, inserts):
    rex = re.compile(find)
    idx = -1
    for line in lines:
        idx += 1        
        if rex.search(line):
            break
    if idx == -1:
        return lines
    l = lines[:idx+1]
    r = lines[idx+1:]
    return l + inserts + r

def safeInt(str, d = 0):
    r = d
    try:
        r = int(str)
    except:
        pass
    return r

PATTERN_HTML_SCRIPT_SRC = re.compile('src="(.+)"')
PATTERN_IMAGESOURCE = re.compile(r'imageSource = ([a-zA-Z0-9:/_.\- ]+);')
        
def buildrelease():
    print("编译release版本")
    # 预处理代码
    prebuildsrc()
    # 重新编译工程
    egret_cmd('build')    
    # 读取配置
    cfg = configparser.ConfigParser()
    cfg.read('.n2.cfg')
    # 清理binrelease
    if os.path.isdir("bin-release"):
        shutil.rmtree("bin-release")
    print('publish版本' + egret_cmd('publish --compressjson'))
    # 获取工作目录
    dir = str(max(map(safeInt, os.listdir('bin-release/web'))))
    # 自动合并release下面的图片
    if cfg.get('dev', 'automerge') == 'y':
        print("自动合并图片")
        processdirs('bin-release/web/' + dir + '/resource/assets/', automergeimages, blacklist=GENRES_BLACKS, depth=2)
        # 因为自动合并图片，需要刷新下bin-release下面的res.json
        genresdbdirectory('bin-release/web/' + dir)    
    # 后处理
    print("复制release版本资源到publish")
    shutil.move('bin-release/web/' + dir + '/resource', 'publish/resource')
    print("合并release版本的代码文件")
    mani = json.loads(readfile('bin-release/web/' + dir + '/manifest.json'))
    libjs = []
    for file in mani['initial']:
        libjs.append(readfile('bin-release/web/' + dir + '/' + file))
    open("publish/engine.min.js", "w").write('\n'.join(libjs))
    gamejs = []    
    for file in mani['game']:        
        # 如果是data文件
        if file.startswith('js/default.data_'):
            shutil.copyfile('bin-release/web/' + dir + '/' + file, 'publish/resource/default.data.js')
        elif file.startswith('js/default.thm_'):
            # 修正编译皮肤编译错的属性
            content = readfile('bin-release/web/' + dir + '/' + file)
            content = PATTERN_IMAGESOURCE.sub(r'imageSource = "\g<1>";', content)
            gamejs.append(content)
        else:
            gamejs.append(readfile('bin-release/web/' + dir + '/' + file))
    open("publish/main.min.js", "w").write('\n'.join(gamejs))
    # 清理数据
    shutil.rmtree('publish/resource/eui_skins')
    # 兼容老版本的theme打包机制
    open('publish/resource/default.thm.json', 'w').write('{}')
    # 拷配置
    shutil.copy('app.json', 'publish/')

# 数据库
def db_get(file, val={}):
    s = shelve.open(file)
    for e in s.keys():
        val[e] = s[e]
    return val

def db_set(obj, file):
    s = shelve.open(file)
    for e in obj.keys():
        s[e] = obj[e]
    s.close()

# 打包资源文件
def distfile(q, sem, file, func, db, prg):
    idx = prg[0]
    sum = prg[1]
    key = hashstring(file)
    if key in db:
        # 如果大小不同，再比对hash，加速
        hash = hashfile(file)
        if hash == db[key]:
            print('COPY %d/%d' %(idx,sum), file)
            shutil.copyfile('.n2~/dist/' + key, file)
            sem.release()
            return
        db[key] = hash
        oldsz = filesize(file)
        func(file)
        newsz = float(filesize(file))
        print('RECOMPRESS %d/%d' %(idx,sum), file, '%d%%' %(newsz/oldsz*100), '%dK' %(newsz/1024))
        shutil.copyfile(file, '.n2~/dist/' + key)
        sem.release()
        return
    hash = hashfile(file)
    db[key] = hash
    oldsz = filesize(file)
    func(file)
    newsz = float(filesize(file))
    print('COMPRESS %d/%d' %(idx,sum), file, '%d%%' %(newsz/oldsz*100), '%dK' %(newsz/1024))
    shutil.copyfile(file, '.n2~/dist/' + key)
    sem.release()

def distpng(file):    
    os.system("pngquant --ext .png --force --speed 1 " + file)

def distjpg(file):
    os.system("jpegoptim -m30 " + file)
    
def distresources():
    # .n2~ 中建立一个数据库，保存历史中的文件优化信息，并保存文件版本，该版本会当目标文件变化时更新，因为.n2~会随着n2build clean清除，所以一定程度上可以忽视image文件大量积压问题
    db = db_get('.n2~/dist.db', multiprocessing.Manager().dict())
    if not os.path.isdir('.n2~/dist'):
        os.mkdir('.n2~/dist')
    # 针对png和jpg分别处理
    pngs = listfiles("publish/resource", whitelist=[re.compile(r'(\.png$)')])
    jpgs = listfiles("publish/resource", whitelist=[re.compile(r'(\.jpg$)')])
    idx = 0
    sum = len(pngs) + len(jpgs)
    # 多进程处理
    sem = multiprocessing.Semaphore(8)
    for png in pngs:
        sem.acquire()
        idx += 1
        q = multiprocessing.Queue()
        p = multiprocessing.Process(target=distfile, args=(q, sem, png, distpng, db, (idx,sum)))
        p.start()
    for jpg in jpgs:
        sem.acquire()
        idx += 1
        # 启动进程
        q = multiprocessing.Queue()
        p = multiprocessing.Process(target=distfile, args=(q, sem, jpg, distjpg, db, (idx,sum)))
        p.start()
    # 额外做一下等待
    time.sleep(10)
    db_set(db, '.n2~/dist.db')
        
def explorer(path):
    subprocess.getstatusoutput("terminal-notifier -title N2BUILD -sound default -message 发布成功 " + "-execute \"open " + path + "\"")

def egret_cmd(cmd):
    _, ot = subprocess.getstatusoutput('egret ' + cmd)
    return ot

# 运行守护进程
def start_deamon():
    pid = os.fork()
    if pid != 0:
        open(HOMEDIR + "/.n2.builder.deamons", 'a').write(str(pid) + '\n')
    return pid == 0

def stop_deamons():
    if not os.path.exists(HOMEDIR + "/.n2.builder.deamons"):
        return
    for pid in get_deamons():
        try:
            os.kill(pid, signal.SIGKILL)
        except:
            pass
    os.unlink(HOMEDIR + "/.n2.builder.deamons")

def get_deamons():
    r = []
    if not os.path.exists(HOMEDIR + "/.n2.builder.deamons"):
        return []
    for line in open(HOMEDIR + "/.n2.builder.deamons", 'r').readlines():
        try:
            r.append(int(line))
        except:
            pass
    return r
                    
# 监听文件变动
def watchfilesystem(name, path, handler):
    lck = GlobalLock(name)
    if lck.acquire() == False:
        return False
    lck.release()
    # 创建工作进程
    #wfs_worker(name, path, handler)
    #return
    if start_deamon():
        wfs_worker(name, path, handler)
    return True
        
def wfs_worker(name, path, handler):
    lck = GlobalLock(name)
    lck.acquire()
    try:
        obs = watchdog.observers.Observer()
        obs.schedule(handler, path, recursive=True)
        obs.start()
        try:
            while True:
                time.sleep(1)
        except KeyboardInterrupt:
            obs.stop()
        obs.join()
    except Exception as err:
        print(err)
    lck.release()

# ----------------------------------- 生成子资源模块 ---------------------------
def svc_subresmaker():
    suc = watchfilesystem("resmaker", "resource/assets", hdl_resmaker())
    # 每次第一次打开，自动重建一下索引
    if suc:
        print("启动resmaker服务")
        resmaker_rebuild()
        
class hdl_resmaker(watchdog.events.FileSystemEventHandler):
    def getinfo(self, e):
        p = e.src_path
        if os.path.isdir(p):
            return None
        res = re.compile(r'resource/assets/(0-9a-zA-Z]+)/(.+)').findall(p)
        if len(res) == 0:
            return None
        res = res[0]
        mod = res[0]
        path = mod + '/' + res[1]
        return (mod, path)
    def rebuild(self, e):
        info = self.getinfo(e)
        if info != None:
            resmaker_buildmod('resource/assets/' + info[0])
    def on_created(self, e):        
        self.rebuild(e)
    def on_deleted(self, e):
        self.rebuild(e)
    def on_moved(self, e):
        self.rebuild(e)
    
def resmaker_rebuild():
    # 刷新资源的索引，默认 resource 下面每一个文件夹都代表一个res-module，里面按照jsonobj保存资源的name-path
    for each in listdirs("resource/assets", depth=1):
        resmaker_buildmod(each)

RESMAKER_BLACKS = [
    re.compile(r'module\.res\.json$'),
    re.compile(r'\.swf$'),
    re.compile(r'\.fla$'),
    re.compile(r'^\.')
]

def resmaker_buildmod(dir):
    files = listfiles(dir, blacklist=RESMAKER_BLACKS)
    # 做成keyvalue
    dict = {}
    for file in files:
        fns = os.path.splitext(os.path.basename(file))
        dict[fns[0] + fns[1]] = {'p':file.replace('resource/assets/', '')}
    # 使用增量的方式可以避免通过工具设置的其它参数被冲掉
    resf = dir + '/module.res.json'
    if os.path.exists(resf):
        try:
            predict = json.loads(''.join(open(resf).readlines()))
        except:
            print('处理 ' + resf + ' 失败')
        for k in dict:
            if k in predict:
                v = predict[k]
                dict[k] = v
    fp = open(resf, 'w')
    fp.write(json.dumps(dict, indent=4))
    fp.close()

# ---------------------------------------- 生成资源数据表 ----------------------
def svc_genresdb():
    suc = watchfilesystem("genresdb", "resource/assets", hdl_genresdb())
    # 如过监听成功，则为第一次打开，保险期间自动刷一次res
    if suc:
        print("启动resdb服务")
        genresdb()

class hdl_genresdb(watchdog.events.FileSystemEventHandler):
    def on_created(self, e):
        p = e.src_path
        if not ismatchs(p, GENRES_BLACKS):            
            genresdb()
    def on_deleted(self, e):
        p = e.src_path
        if not ismatchs(p, GENRES_BLACKS):            
            genresdb()
    def on_moved(self, e):
        p = e.src_path
        if not ismatchs(p, GENRES_BLACKS):            
            genresdb()

# 拆分成文件名和文件后缀
def split_filename(file):
    sp = os.path.splitext(os.path.basename(file))
    ext = sp[1]
    if '.' in ext:
        return [sp[0], ext[1:]]    
    return [sp[0], '']

def egretfileinfo(file):
    dir = os.path.dirname(file)
    sp = split_filename(file)
    name = sp[0] # + '_' + sp[1], 不使用 _ 来分割
    r = {}
    if '_automerged_' in name:
        if sp[1] == 'png':
            return None
        name = sp[0] + '_json'
        type = 'sheet'
        # 读取subkeys
        jsobj = json.loads(readfile(file))
        frmobjs = jsobj['frames']
        r['subkeys'] = ','.join(frmobjs.keys())
    elif sp[1] == 'png':
        if os.path.isfile(dir + '/' + sp[0] + '.json') or os.path.isfile(dir + '/' + sp[0] + '.fnt'):
            name = sp[0] + '_png'
        type = 'image'
    elif sp[1] == 'jpg':
        type = 'image'        
    elif sp[1] == 'json':
        # 如过同时存在 file_png 和 file_json 的队列，则认为是特殊资源，需要保持命名
        if os.path.isfile(dir + '/' + sp[0] + '.png'):
            name = sp[0] + '_json'
        type = 'json'
    elif sp[1] == 'ttf':
        name = sp[0] + '_ttf'
        type = 'font'        
    elif sp[1] == 'fnt':
        name = sp[0] + '_fnt'
        type = 'font'
    else:
        type = 'bin'
    r['name'] = name
    r['type'] = type
    return r

GENRES_BLACKS = RESMAKER_BLACKS + [re.compile(r'\.d/|\.d$')]

def genresdb():
    # 遍历所有的子文件，找出png\jpg\json，生成default.res.json文件并生成对应的group
    jsobj = {'groups':[], 'resources':[]}
    # 第一级的资源为不加入group中的
    for file in listfiles('resource/assets', blacklist=GENRES_BLACKS, depth=1):
        info = egretfileinfo(file)
        if info == None:
            continue
        info['url'] = file.replace('resource/', '')
        jsobj['resources'].append(info)
    # 处理其他级别的目录
    def proc(path, dirname):
        keys = []
        parts = []
        for file in listfiles(path, blacklist=GENRES_BLACKS, depth=1):
            info = egretfileinfo(file)
            if info == None:
                continue
            info['url'] = file.replace('resource/', '')
            keys.append(info['name'])
            parts.append(info)
        jsobj['groups'].append({'name':dirname.replace('/', '_'),
                                'keys':','.join(keys)})
        jsobj['resources'] += parts
    processdirs("resource/assets", proc, blacklist=GENRES_BLACKS, depth=2)
    open('resource/default.res.json', 'w').write(json.dumps(jsobj, indent=4))

def genresdbdirectory(dir):
    jsobj = {'groups':[], 'resources':[]}
    for file in listfiles(dir + '/resource/assets', blacklist=GENRES_BLACKS, depth=1):
        info = egretfileinfo(file)
        if info == None:
            continue
        info['url'] = file.replace(dir + '/resource/', '')
        jsobj['resources'].append(info)
    def proc(path, dirname):
        keys = []
        parts = []
        for file in listfiles(path, blacklist=GENRES_BLACKS, depth=1):
            info = egretfileinfo(file)
            if info == None:
                continue
            info['url'] = file.replace(dir + '/resource/', '')
            keys.append(info['name'])
            parts.append(info)
        jsobj['groups'].append({'name':dirname.replace('/', '_'),
                                'keys':','.join(keys)})
        jsobj['resources'] += parts
    processdirs(dir + "/resource/assets", proc, blacklist=GENRES_BLACKS, depth=2)
    open(dir + '/resource/default.res.json', 'w').write(json.dumps(jsobj, indent=4))

AUTOMERGE_BLACKS = GENRES_BLACKS + [re.compile(r'\.g/|\.g$')]

def pubres():
    cfg = configparser.ConfigParser()
    cfg.read('.n2.cfg')
    shutil.rmtree('publish', True)
    print('copy资源')
    shutil.copytree('resource', 'publish/resource')
    if cfg.get('dev', 'automerge') == 'y':
        print('自动合并资源')
        processdirs('publish/resource/assets', automergeimages, blacklist=AUTOMERGE_BLACKS, depth=2)
        genresdbdirectory('publish')

# ---------------------------------------- 维护Skin和实现类之间的关系 --------------
def skinimpl_regen():
    # 如过不存在skin文件夹，跳过
    if not os.path.isdir('resource/eui_skins/app'):
        return
    # 列出所有的skin
    skins = listfiles('resource/eui_skins/app', whitelist=[re.compile(r'\.exml$')])
    # 生成对应的实现文件
    thms = [
        '"eui.ButtonU":"resource/eui_skins/wgt/ButtonSkin.exml"',
        '"eui.CheckBoxU":"resource/eui_skins/wgt/CheckBoxSkin.exml"',
        '"eui.ToggleSwitchU":"resource/eui_skins/wgt/ToggleSwitchSkin.exml"',
        '"eui.TextInputU":"resource/eui_skins/wgt/TextInputSkin.exml"',
        '"eui.ScrollerU":"resource/eui_skins/wgt/ScrollerSkin.exml"',
        '"eui.ItemRendererU":"resource/eui_skins/wgt/ItemRendererSkin.exml"',
        '"eui.VScrollBar":"resource/eui_skins/wgt/VScrollBarSkin.exml"',
        '"eui.HScrollBar":"resource/eui_skins/wgt/HScrollBarSkin.exml"',
        '"eui.ProgressBarU":"resource/eui_skins/wgt/ProgressBarSkin.exml"'
    ]
    for skin in skins:
       cls = skinimpl_genfile(skin)
       if cls:
           thms.append('"' + cls + '":"' + skin + '"')
    # 重新生成default.thm.json
    open('resource/default.thm.json', 'w').write(string.Template("""{
    "autoGenerateExmlsList": true,
    "exmls": [],
    "skins": {${SKINS}}
}""").substitute({
    'SKINS': ',\n'.join(thms)
    }))

def skinimpl_genfile(file):
    # 解析xml
    try:
        xml = minidom.parse(file)
    except:
        return None
    root = xml.documentElement
    # 查找所有的id
    nodes = dom_getElementsByAttributeName(root, 'id')
    slots = dom_getAttributesByName(root, 'slots')
    # 提取变量
    props = []
    for node in nodes:
        id = node.getAttribute('id')
        ns = node.namespaceURI
        nm = node.nodeName
        cls = nm[nm.index(':')+1:]
        e = nm[:nm.index(':')]
        if e != 'e':
            cls = ns.replace('*', cls)
        else:
            cls = 'eui.' + cls
        props.append('        ' + id + ':' + cls + ';\n')
    # 排序
    slots.sort()
    props.sort()
    # 处理对应的实现文件
    # 提取名称
    srcls = file[file.index('resource/'):].replace('resource/eui_skins/', '').replace('Skin.exml', '')
    srcfn = 'src/' + srcls + '.ts'
    # 如果不存在，则需要根据模版生成新的文件
    if not os.path.exists(srcfn):
        # modname
        mdnm = os.path.dirname(srcls).replace('/', '.')
        # 创建目录
        dir = os.path.dirname(srcfn)
        if not os.path.exists(dir):
            os.makedirs(dir)
        cnt = string.Template("""
module ${MODULE} {\n
    interface I${CLASS}
    {
        //slot {
        //slot }
    }

    export class ${CLASS}
    extends eui.SpriteU
    implements I${CLASS}
    {
        //skin {
        //skin }
    }
\n}
""").substitute({
    'MODULE': mdnm,
    'CLASS': os.path.basename(srcls)
})
        try:
            open(srcfn, 'w').write(cnt)
        except:
            print(srcfn + "保存处理过的xml失败")
            raise
    # 生成interface需要的函数
    funs = set()
    for slot in slots:
        for each in slot.split(';'):
            if each == '':
                continue
            a = each.split('=>')
            if len(a) != 2:
                continue
            funs.add('        _' + a[1] + '(s?:nn.Slot);\n')            
    # 读取文件，插入对应的变量
    lines = open(srcfn).readlines()
    lines = lines_replace(lines, '//skin {', '//skin }', props)
    lines = lines_replace(lines, '//slot {', '//slot }', list(funs))
    codecs.open(srcfn, 'w', 'utf-8').write(''.join(lines))
    # 返回类名
    return srcls.replace('/', '.')

def dom_getElementsByAttributeName(node, name, r=None):
    if r == None:
        r = []
    for each in node.childNodes:
        if each.nodeType != each.ELEMENT_NODE:
            continue
        if each.hasAttribute(name):
            r.append(each)
        dom_getElementsByAttributeName(each, name, r)
    return r

def dom_getAttributesByName(node, name, r=None):
    if r == None:
        r = []
    if node.nodeType != node.ELEMENT_NODE:
        return r
    if node.hasAttribute(name):
        r.append(node.getAttribute(name))
    for each in node.childNodes:
        dom_getAttributesByName(each, name, r)
    return r

def svc_genskinimpls():
    if not os.path.isdir("resource/eui_skins/app"):
        return
    suc = watchfilesystem("genskinimpls", "resource/eui_skins/app", hdl_genskinimpls())
    if suc:
        print("启动skinimpls服务")
        skinimpl_regen()

class hdl_genskinimpls(watchdog.events.FileSystemEventHandler):
    def on_modified(self, e):
        p = e.src_path
        if not p.endswith('.exml'):
            return
        skinimpl_genfile(p)
    def on_created(self, e):
        p = e.src_path
        if not p.endswith('.exml'):
            return
        cls = skinimpl_genfile(p)
        exml = p[p.index('resource/'):]
        obj = json.loads(readfile('resource/default.thm.json'))
        if cls not in obj['skins']:
            obj['skins'][cls] = exml
        open('resource/default.thm.json', 'w').write(json.dumps(obj))
    def on_deleted(self, e):
        p = e.src_path
        if not p.endswith('.exml'):
            return
        srcls = p[p.index('resource/'):].replace('resource/eui_skins/', '').replace('Skin.exml', '')
        cls = srcls.replace('/', '.')
        obj = json.loads(readfile('resource/default.thm.json'))
        if cls in obj['skins']:
            obj['skins'].pop(cls)
        open('resource/default.thm.json', 'w').write(json.dumps(obj))
    def on_moved(self, e):
        p = e.dest_path
        if not ismatchs(p, GENRES_BLACKS):            
            genresdb()

# ---------------------------------------- 生成debug.html --------------------------------
def debugindex():
    content = readfile('index.html')
    content = re.sub('<!--[^-->]+-->', '', content)
    open('debug.html', 'w').write(content)
    
# ---------------------------------------- Main --------------------------------
def main():
    checkconfig()
    # 处理主命令
    try:
        opts, args = getopt.getopt(sys.argv[1:], "-t", [''])
    except getopt.GetoptError:
        usage()
        return    
    if 'service' in args:
        cmd = args[args.index('service') + 1]
        if cmd == 'list':
            print(get_deamons())
            return
        elif cmd == 'stop':
            stop_deamons()
            return
    elif 'genres' in args:
        genresdb()
        return
    elif 'pubres' in args:
        pubres()
        return
    elif 'distres' in args:
        pubres()
        distresources()
        return
    elif 'checkout' in args:
        stop_deamons()
        os.system("git checkout " + args[args.index('checkout') + 1])
        return
    elif 'debugindex' in args:
        debugindex()
        return
    if 'null' in args:
        return
    # 尝试运行持久任务
    if ('-t', '') not in opts:
        svc_genresdb()
        svc_genskinimpls()
        # svc_subresmaker()
    else:
        # 需要直接运行服务的内容
        genresdb()
        skinimpl_regen()
    if 'config' in args:
        makeconfig(True)
        return
    if 'clean' in args:
        clean()
        return
    # 是否需要重新生成index
    if 'publish' in args:
        # 去除publish引起的egret自动判断文件混乱
        shutil.rmtree('publish', True)
        buildrelease()
        prindex()
        # 重新生成resource的目录
        cfg = configparser.ConfigParser()
        cfg.read('.n2.cfg')
        resdir = 'publish/resource'
        if cfg.get('app', 'resource') == 'p':
            resdir = resdir + '_' + cfg.get('app', 'version')
            shutil.move('publish/resource', resdir)
        explorer('publish')
    elif 'dist' in args:
        debug = 'debug' in args
        # 去除publish引起的egret自动判断文件混乱
        shutil.rmtree('publish', True)
        if debug:
            builddebug()
            pdindex()
            copydebugtopublish()
            distresources()
        else:
            buildrelease()
            prindex()
            distresources()
            # 重新生成resource的目录
            cfg = configparser.ConfigParser()
            cfg.read('.n2.cfg')
            resdir = 'publish/resource'
            if cfg.get('app', 'resource') == 'p':
                resdir = resdir + '_' + cfg.get('app', 'version')
                os.symlink('./resource', resdir)
        explorer('publish')
    else:
        builddebug()
        pdindex()
    cfgdb['bver'] = version

## 模版
TPL_INDEX_DEBUG="""
<!DOCTYPE HTML>
<html>
<head>
    <meta charset="utf-8">
    <title>${APPNAME}</title>
    <meta name="viewport"
          content="width=device-width, initial-scale=1, minimum-scale=1, maximum-scale=1, user-scalable=no"/>
    <meta name="apple-mobile-web-app-capable" content="yes"/>
    <meta name="screen-orientation" content="${APPORI}"/>
    <meta name="x5-orientation" content="${APPORI}"/>
    <meta name="full-screen" content="true"/>
    <meta name="x5-fullscreen" content="true"/>
    <meta name="360-fullscreen" content="true"/>
    <meta name="renderer" content="webkit"/>
    <meta name="browsermode" content="application"/>
    <meta name="x5-page-mode" content="app"/>
    <meta http-equiv="X-UA-Compatible" content="IE=edge"/>
    <app content="${APPCONTENT}">
    </app>
    <style>
        html, body {
            -ms-touch-action:none;
            padding:0;
            border:0;
            margin:0;
            height:100%;
            background:${BACKGROUNDCOLOR}
        }
        #launchDiv {
            position:absolute;
            left:0;
            top:0;
            text-align:center;
            width:100%;
            height:100%;
            background:url(${BACKGROUND}) top center no-repeat;
            background-size:auto 100%;
        }
    </style>
    ${APPSTYLE}
</head>
<body>
    <div id="launchDiv">        
    ${APPLAUNCH}
    </div>
    ${APPSCRIPT}
    <div style="margin:auto;width:100%;height:100%;" class="egret-player"
         data-entry-class="Main"
         data-orientation="auto"
         data-scale-mode="showAll"
         data-multi-fingered="2"
         data-frame-rate="60"
         >
    </div>
    <!-- debug信息 -->
    <script src="src/app/~debug.js"></script>
    <!-- dev工具 -->
    <script src="tools/devtools/devtools.js" type="text/javascript"></script>
    <!-- 加载的文件列表 -->
    ${FILESLIST}
    <script>
        var document_orientation = ${APPANGLE};
    	nn.loader.webstart();        
    </script>
</body>
</html>
"""

TPL_INDEX_RELEASE="""
<!DOCTYPE HTML>
<html>
<head>
    <meta charset="utf-8">
    <title>${APPNAME}</title>
    <meta name="viewport" 
          content="width=device-width, initial-scale=1, minimum-scale=1, maximum-scale=1, user-scalable=no"/>
    <meta name="apple-mobile-web-app-capable" content="yes"/>
    <meta name="screen-orientation" content="${APPORI}"/>
    <meta name="x5-orientation" content="${APPORI}"/>
    <meta name="full-screen" content="true"/>
    <meta name="x5-fullscreen" content="true"/>
    <meta name="360-fullscreen" content="true"/>
    <meta name="renderer" content="webkit"/>
    <meta name="browsermode" content="application"/>
    <meta name="x5-page-mode" content="app"/>
    <meta http-equiv="X-UA-Compatible" content="IE=edge"/>
    <app content="${APPCONTENT}"
         icon="${APPICON}"
         name="${APPNAME}">
    </app>
    <style>
        html, body {
            -ms-touch-action:none;
            padding:0;
            border:0;
            margin:0;
            height:100%;
            background:${BACKGROUNDCOLOR}
        }
        #launchDiv {
            position:absolute;
            left:0;
            top:0;
            text-align:center;
            width:100%;
            height:100%;
            background:url(${BACKGROUND}) top center no-repeat;
            background-size:auto 100%;
        }
    </style>
    ${APPSTYLE}
</head>
<body>
    <div id="launchDiv">
    ${APPLAUNCH}
    </div>
    ${APPSCRIPT}
    <div style="margin:auto;width:100%;height:100%;" class="egret-player"
         data-entry-class="Main"
         data-orientation="auto"
         data-scale-mode="showAll"
         data-multi-fingered="2"
         data-frame-rate="60"
         >
    </div>
    ${FILESLIST}
    <script>
        var document_orientation = ${APPANGLE};
        nn.loader.webstart();        
    </script>
</body>
</html>
"""

# 判断是否符合一组re的判定
def ismatchs(str, rexs, non=False):
    if rexs == None:
        return non
    for be in rexs:
        bl = len(be.findall(str))
        if bl:
            return True
    return False

# 列出文件夹下所有文件，黑名单为rex
def listfiles(dir, rets = None, blacklist = None, whitelist = None, depth = -1):
    if depth == 0:
        return rets
    elif depth != -1:
        depth -= 1
    if rets == None:
        rets = []
    if os.path.isdir(dir) == False:
        return rets
    for each in os.listdir(dir):
        # 如果是文件夹则不过滤直接迭代
        path = dir + '/' + each
        if os.path.isdir(path):
            listfiles(path, rets, blacklist, whitelist, depth)
        else:
            # 黑名单过滤
            ignore = False
            if blacklist:
                for be in blacklist:
                    ignore = len(be.findall(each))
                    if ignore:
                        break        
                if ignore:
                    continue
            # 白名单过滤
            if whitelist:
                for we in whitelist:
                    ignore = not len(we.findall(each))
                    if not ignore:
                        break
                if ignore:
                    continue
            rets.append(path)
    return rets

def listdirs(dir, rets = None, blacklist = None, depth = -1):
    if depth == 0:
        return rets
    elif depth != -1:
        depth -= 1
    if rets == None:
        rets = []
    if os.path.isdir(dir) == False:
        return rets
    for each in os.listdir(dir):
        bl = False
        if blacklist:
            for be in blacklist:
                bl = len(be.findall(each))
                if bl:
                    break
        if bl:
            continue
        path = dir + '/' + each
        if os.path.isdir(path):
            rets.append(path)
            listdirs(path, rets, blacklist, depth)
    return rets

def processdirs(dir, proc, blacklist = None, depth = -1, curdir = None):
    if depth == 0:
        return
    elif depth != -1:
        depth -= 1
    if os.path.isdir(dir) == False:
        return
    for each in os.listdir(dir):
        bl = False
        if blacklist:
            for be in blacklist:
                bl = len(be.findall(each))
                if bl:
                    break
        if bl:
            continue
        path = dir + '/' + each
        if not os.path.isdir(path):
            continue
        if curdir == None:
            cd = each
        else:
            cd = curdir + '/' + each
        proc(path, cd)
        processdirs(path, proc, blacklist, depth, cd)

# 清空工程
def clean():
    if os.path.isfile('.n2~/build'):
        os.unlink('.n2~/build')
    if os.path.isdir('libs'):
        shutil.rmtree('libs')
    if os.path.isdir('bin-debug'):
        shutil.rmtree('bin-debug')
    if os.path.isdir('src/app/~tsc'):
        shutil.rmtree('src/app/~tsc')
    if os.path.isfile('.n2~/dist.db'):
        os.unlink('.n2~/dist.db')
    if os.path.isdir('.n2~/dist'):
        shutil.rmtree('.n2~/dist')

# ------------------------------- 自动合并图片 ---------------------------------
PATTERN_FILENAME_EXT = re.compile(r'(.+)\.(.+)')
IMAGE_EXTS = ['jpeg', 'jpg', 'png']
            
def automergeimages(dir, name):
    print("自动合并 " + dir)
    name = name.replace('/', '_').lower()
    files = []
    for ef in os.listdir(dir):        
        fnd = PATTERN_FILENAME_EXT.search(ef)
        if fnd and fnd.group(2) in IMAGE_EXTS:        
            files.append((fnd.group(1), fnd.group(2)))
    print("找到了 " + str(len(files)) + " 个文件用于自动合图")
    ignores = []
    for ef in files:
        ext = ef[1]
        if ext == 'fnt':
            ignores.append(ef)
        elif ext == 'json':
            ignores.append(ef)
        elif ext == 'jpg':
            ignores.append(ef)        
    for ef in ignores:        
        nm = ef[0]
        ext = ef[1]
        if ext == 'fnt':            
            try:
                files.remove(ef)
                files.remove((nm, 'png'))
                files.remove((nm, 'tmf'))
            except:
                pass
        elif ext == 'json':
            try:
                files.remove(ef)
                files.remove((nm, 'png'))
            except:
                pass
        elif ext == 'jpg':
            files.remove(ef)
    images = []
    for ef in files:        
        path = dir + '/' + ef[0] + '.' + ef[1]
        img = Image.open(path)
        if img == None:
            print('打开图像 ' + path + ' 失败')
            continue
        bbx = img.getbbox()
        size = img.size        
        if bbx == None:
            print("图片的bbx为空，使用整张图片 " + path)
            bbx = (0, 0, size[0], size[1])
        else:
            img = img.crop(bbx)
        images.append({
            'name': ef[0],
            'path': path,
            'frame':None,
            'origin':{'offx':bbx[0], 'offy':bbx[1], 'w':size[0], 'h':size[1]},
            'img':img
        })
    images = sorted(images, key=functools.cmp_to_key(mergesort))
    if len(images) == 0: #不处理空的组
        return
    workid = 0
    while True:
        work = {'work':Image.new('RGBA', (2048, 2048), (0, 0, 0, 0)),
                'result':[]}
        res = mergeImages(work, images, (0, 0, 2048, 2048))
        png = work['work']        
        png.crop(png.getbbox()).save(dir + '/' + name + '_automerged_' + str(workid) + '.png')
        frmobjs = {}
        for e in work['result']:
            frame = e['frame']
            origin = e['origin']
            frmobjs[e['name']] = {
                'x':frame['x'], 'y':frame['y'], 'w':frame['w'], 'h':frame['h'],
                'offX':origin['offx'], 'offY':origin['offy'],
                'sourceW':origin['w'], 'sourceH':origin['h']
            }
            # 删除对应的图片，这个地方的脚本和 tools/mergeimgs 不同
            os.unlink(e['path'])
        jsobj = {'file':name + "_automerged_" + str(workid) + ".png",
                 'frames':frmobjs}
        open(dir + '/' + name + '_automerged_' + str(workid) + ".json", 'w').write(json.dumps(jsobj))
        workid += 1
        if res == True:
            break

def mergesort(l, r):
    if l['img'] == None:
        return 0
    if r['img'] == None:
        return 0
    lsz = l['img'].size
    rsz = r['img'].size
    return rsz[1] - lsz[1]

def mergeImages(work, images, rc):
    if len(images) == 0:
        return True
    image = None
    for e in images:        
        sz = e['img'].size
        if rc[3] < sz[1]:
            continue
        if rc[2] < sz[0]:
            continue
        image = e
        break
    if image == None:
        return False
    images.remove(image)
    img = image['img']    
    sz = img.size
    work['work'].paste(img, (rc[0], rc[1], (rc[0] + sz[0]), rc[1] + sz[1]))
    image['frame'] = {'x':rc[0], 'y':rc[1], 'w':sz[0], 'h':sz[1]}
    work['result'].append(image)
    if mergeImages(work, images, (rc[0] + sz[0], rc[1], rc[2] - sz[0], sz[1])):
        return True
    return mergeImages(work, images, (rc[0], rc[1] + sz[1], rc[2], rc[3] - sz[1]))    
            
# ------------------------------- 主脚本执行 -----------------------------------
if __name__=="__main__":
    cfgdb = shelve.open('.n2~/build')    
    main()
    cfgdb.close()
    
